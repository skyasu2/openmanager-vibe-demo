<!-- cpu-analysis.html - CPU 사용률 분석 페이지 (개선 버전) -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenManager 7.0 - CPU 사용률 분석</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js">    </script>
</body>
</html>
</head>
<body>
    <header>
        <div class="logo">OpenManager 7.0</div>
        <nav>
            <ul>
                <li><a href="index.html">대시보드</a></li>
                <li><a href="demo.html">서버 요약</a></li>
                <li><a href="cpu-analysis.html" class="active">CPU 분석</a></li>
            </ul>
        </nav>
        <div class="controls">
            <select id="timeRange" class="time-range">
                <option value="24">최근 24시간</option>
                <option value="48">최근 48시간</option>
                <option value="72">최근 72시간</option>
                <option value="168" selected>최근 7일</option>
            </select>
            <button id="refreshBtn" class="btn">새로고침</button>
        </div>
    </header>

    <!-- 로딩 인디케이터 -->
    <div id="loading" class="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- 오류 메시지 -->
    <div id="error-message" class="error-message"></div>

    <main>
        <div class="full-width-card">
            <h2>CPU 사용률 분석</h2>
            <div class="filter-controls">
                <div class="filter-group">
                    <label for="serverTypeFilter">서버 유형:</label>
                    <select id="serverTypeFilter">
                        <option value="all">모든 유형</option>
                        <!-- 동적으로 채워질 서버 유형 -->
                    </select>
                </div>
                <div class="filter-group">
                    <label for="locationFilter">위치:</label>
                    <select id="locationFilter">
                        <option value="all">모든 위치</option>
                        <!-- 동적으로 채워질 위치 -->
                    </select>
                </div>
                <div class="filter-group">
                    <label for="thresholdFilter">임계값:</label>
                    <select id="thresholdFilter">
                        <option value="0">모두 표시</option>
                        <option value="50">50% 이상</option>
                        <option value="70">70% 이상</option>
                        <option value="90">90% 이상</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="serverCountSelect">표시할 서버:</label>
                    <select id="serverCountSelect">
                        <option value="5">상위 5개</option>
                        <option value="10" selected>상위 10개</option>
                        <option value="20">상위 20개</option>
                        <option value="all">모두</option>
                    </select>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="cpuTrendChart"></canvas>
            </div>
        </div>

        <div class="half-width-card">
            <h2>평균 CPU 사용률 (서버 유형별)</h2>
            <div class="chart-container">
                <canvas id="cpuByTypeChart"></canvas>
            </div>
        </div>

        <div class="half-width-card">
            <h2>최고 CPU 사용률 서버</h2>
            <div class="chart-container">
                <canvas id="topCpuServersChart"></canvas>
            </div>
        </div>

        <div class="full-width-card">
            <h2>실시간 CPU 사용률 임계값 초과 서버</h2>
            <div class="table-container">
                <table id="highCpuTable" class="data-table">
                    <thead>
                        <tr>
                            <th>서버 이름</th>
                            <th>서버 유형</th>
                            <th>위치</th>
                            <th class="centered">CPU 사용률</th>
                            <th class="centered">메모리 사용률</th>
                            <th class="centered">디스크 사용률</th>
                            <th>마지막 업데이트</th>
                            <th class="centered">상태</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- 데이터로 동적 채우기 -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="full-width-card">
            <h2>CPU 사용률 상관관계 분석</h2>
            <div class="filter-controls">
                <div class="filter-group">
                    <label for="correlationMetric">비교 지표:</label>
                    <select id="correlationMetric">
                        <option value="memory">메모리 사용률</option>
                        <option value="disk">디스크 사용률</option>
                        <option value="network">네트워크 트래픽</option>
                        <option value="requests">요청 수</option>
                    </select>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="correlationChart"></canvas>
            </div>
            <div class="correlation-info">
                <p>상관계수: <span id="correlationCoefficient">-</span></p>
                <p>분석 결과: <span id="correlationAnalysis">-</span></p>
            </div>
        </div>

        <div class="half-width-card">
            <h2>CPU 사용률 분포</h2>
            <div class="chart-container">
                <canvas id="cpuDistributionChart"></canvas>
            </div>
        </div>

        <div class="half-width-card">
            <h2>위치별 평균 CPU 사용률</h2>
            <div class="chart-container">
                <canvas id="cpuByLocationChart"></canvas>
            </div>
        </div>
    </main>

    <script src="data_processor.js"></script>
    <script>
        // 데이터 로드 및 차트 초기화
        let dataProcessor;
        let cpuTrendChart, cpuByTypeChart, topCpuServersChart, correlationChart, cpuDistributionChart, cpuByLocationChart;
        
        // 차트 색상 설정
        const chartColors = [
            'rgba(52, 152, 219, 0.7)', 'rgba(46, 204, 113, 0.7)', 
            'rgba(155, 89, 182, 0.7)', 'rgba(52, 73, 94, 0.7)',
            'rgba(241, 196, 15, 0.7)', 'rgba(230, 126, 34, 0.7)',
            'rgba(231, 76, 60, 0.7)', 'rgba(149, 165, 166, 0.7)',
            'rgba(26, 188, 156, 0.7)', 'rgba(41, 128, 185, 0.7)',
        ];
        
        // 필터 상태
        const filters = {
            serverType: 'all',
            location: 'all',
            threshold: 0,
            serverCount: 10
        };
        
        async function initPage() {
            try {
                // 로딩 표시
                showLoading();
                
                // 데이터 로드
                dataProcessor = await loadServerData('mock_data_100servers.json');
                if (!dataProcessor) {
                    showError("서버 데이터를 로드할 수 없습니다.");
                    hideLoading();
                    return;
                }
                
                // 필터 초기화
                initializeFilters();
                
                // 차트 초기화
                initializeCharts();
                
                // 테이블 초기화
                updateHighCpuTable();
                
                // 이벤트 리스너 설정
                setupEventListeners();
                
                // 로딩 숨기기
                hideLoading();
                
            } catch (error) {
                console.error('페이지 초기화 중 오류 발생:', error);
                showError("페이지를 초기화하는 중 오류가 발생했습니다.");
                hideLoading();
            }
        }
        
        function initializeFilters() {
            // 서버 유형 필터 채우기
            const serverTypes = Object.keys(dataProcessor.getServersByType());
            const serverTypeFilter = document.getElementById('serverTypeFilter');
            
            serverTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                serverTypeFilter.appendChild(option);
            });
            
            // 위치 필터 채우기
            const locations = Object.keys(dataProcessor.getStatusByLocation());
            const locationFilter = document.getElementById('locationFilter');
            
            locations.forEach(location => {
                const option = document.createElement('option');
                option.value = location;
                option.textContent = location;
                locationFilter.appendChild(option);
            });
            
            // 필터 상태 초기화
            filters.serverCount = parseInt(document.getElementById('serverCountSelect').value);
            if (isNaN(filters.serverCount)) filters.serverCount = 10;
        }
        
        function initializeCharts() {
            // CPU 추세 차트
            initCpuTrendChart();
            
            // 서버 유형별 CPU 사용률 차트
            initCpuByTypeChart();
            
            // 상위 CPU 사용률 서버 차트
            initTopCpuServersChart();
            
            // 상관관계 차트
            initCorrelationChart();
            
            // CPU 분포 차트
            initCpuDistributionChart();
            
            // 위치별 CPU 사용률 차트
            initCpuByLocationChart();
        }
        
        function initCpuTrendChart() {
            const ctx = document.getElementById('cpuTrendChart').getContext('2d');
            
            // 시간별 시스템 상태 가져오기
            const hourlyData = dataProcessor.getHourlySystemStatus();
            
            // 차트 데이터 준비
            const labels = hourlyData.map(hour => hour.timestamp);
            const cpuData = hourlyData.map(hour => hour.avgCpu);
            
            cpuTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '평균 CPU 사용률 (%)',
                        data: cpuData,
                        borderColor: 'rgba(52, 152, 219, 1)',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'CPU 사용률 (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '시간'
                            }
                        }
                    }
                }
            });
        }
        
        function initCpuByTypeChart() {
            const ctx = document.getElementById('cpuByTypeChart').getContext('2d');
            
            // 서버 유형별 데이터 가져오기
            const serversByType = dataProcessor.getServersByType();
            const avgCpuByServer = dataProcessor.getAverageCpuUsageByServer();
            
            // 유형별 평균 계산
            const typeLabels = [];
            const typeData = [];
            
            Object.entries(serversByType).forEach(([type, servers]) => {
                typeLabels.push(type);
                
                // 이 유형의 모든 서버의 평균 CPU 사용률 계산
                const totalCpu = servers.reduce((sum, server) => sum + avgCpuByServer[server], 0);
                const avgCpu = servers.length > 0 ? totalCpu / servers.length : 0;
                
                typeData.push(avgCpu);
            });
            
            cpuByTypeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: typeLabels,
                    datasets: [{
                        label: '평균 CPU 사용률 (%)',
                        data: typeData,
                        backgroundColor: chartColors.slice(0, typeLabels.length),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'CPU 사용률 (%)'
                            }
                        }
                    }
                }
            });
        }
        
        function initTopCpuServersChart() {
            const ctx = document.getElementById('topCpuServersChart').getContext('2d');
            
            // 평균 CPU 사용률 가져오기
            const avgCpuByServer = dataProcessor.getAverageCpuUsageByServer();
            
            // 상위 10개 서버 찾기
            const serverEntries = Object.entries(avgCpuByServer);
            serverEntries.sort((a, b) => b[1] - a[1]); // 내림차순 정렬
            
            const topServers = serverEntries.slice(0, 10);
            const serverNames = topServers.map(entry => entry[0]);
            const cpuValues = topServers.map(entry => entry[1]);
            
            topCpuServersChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: serverNames,
                    datasets: [{
                        label: 'CPU 사용률 (%)',
                        data: cpuValues,
                        backgroundColor: chartColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'CPU 사용률 (%)'
                            }
                        }
                    }
                }
            });
        }
        
        function initCorrelationChart() {
            const ctx = document.getElementById('correlationChart').getContext('2d');
            
            // 현재 상태 요약 가져오기
            const currentStatus = dataProcessor.getCurrentStatusSummary();
            
            // CPU와 메모리 사용률 데이터 준비
            const dataPoints = Object.values(currentStatus).map(server => ({
                x: server.stats.cpuUsage,
                y: server.stats.memoryUsage,
                serverName: server.serverName,
                serverType: server.serverType,
                location: server.location
            }));
            
            correlationChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'CPU vs 메모리 사용률',
                        data: dataPoints,
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                        borderColor: 'rgba(52, 152, 219, 1)',
                        borderWidth: 1,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataPoint = context.raw;
                                    return [
                                        `서버: ${dataPoint.serverName}`,
                                        `유형: ${dataPoint.serverType}`,
                                        `위치: ${dataPoint.location}`,
                                        `CPU: ${dataPoint.x.toFixed(1)}%`,
                                        `메모리: ${dataPoint.y.toFixed(1)}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'CPU 사용률 (%)'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '메모리 사용률 (%)'
                            }
                        }
                    }
                }
            });
            
            // 상관계수 계산 및 표시
            updateCorrelationAnalysis('memory');
        }
        
        function initCpuDistributionChart() {
            const ctx = document.getElementById('cpuDistributionChart').getContext('2d');
            
            // 평균 CPU 사용률 가져오기
            const avgCpuByServer = dataProcessor.getAverageCpuUsageByServer();
            const cpuValues = Object.values(avgCpuByServer);
            
            // CPU 사용률 분포 계산 (0-10%, 10-20%, ...)
            const distribution = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 10개 구간
            cpuValues.forEach(value => {
                const index = Math.min(9, Math.floor(value / 10));
                distribution[index]++;
            });
            
            const labels = ['0-10%', '10-20%', '20-30%', '30-40%', '40-50%', '50-60%', '60-70%', '70-80%', '80-90%', '90-100%'];
            
            cpuDistributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '서버 수',
                        data: distribution,
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                        borderColor: 'rgba(52, 152, 219, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '서버 수'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'CPU 사용률 범위'
                            }
                        }
                    }
                }
            });
        }
        
        function initCpuByLocationChart() {
            const ctx = document.getElementById('cpuByLocationChart').getContext('2d');
            
            // 위치별 상태 가져오기
            const locationStatus = dataProcessor.getStatusByLocation();
            
            // 데이터 준비
            const locations = Object.keys(locationStatus);
            const cpuData = locations.map(location => locationStatus[location].avgCpu);
            
            cpuByLocationChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: locations,
                    datasets: [{
                        label: '평균 CPU 사용률 (%)',
                        data: cpuData,
                        backgroundColor: chartColors.slice(0, locations.length),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'CPU 사용률 (%)'
                            }
                        }
                    }
                }
            });
        }
        
        function updateHighCpuTable() {
            const tableBody = document.querySelector('#highCpuTable tbody');
            tableBody.innerHTML = ''; // 테이블 내용 지우기
            
            // 현재 상태 요약 가져오기
            const currentStatus = dataProcessor.getCurrentStatusSummary();
            
            // 필터 적용
            let filteredServers = Object.values(currentStatus);
            
            // 서버 유형 필터링
            if (filters.serverType !== 'all') {
                filteredServers = filteredServers.filter(server => server.serverType === filters.serverType);
            }
            
            // 위치 필터링
            if (filters.location !== 'all') {
                filteredServers = filteredServers.filter(server => server.location === filters.location);
            }
            
            // CPU 임계값 필터링
            if (filters.threshold > 0) {
                filteredServers = filteredServers.filter(server => server.stats.cpuUsage >= filters.threshold);
            }
            
            // CPU 사용률로 정렬
            filteredServers.sort((a, b) => b.stats.cpuUsage - a.stats.cpuUsage);
            
            // 표시할 서버 수 제한
            if (filters.serverCount !== 'all' && !isNaN(filters.serverCount)) {
                filteredServers = filteredServers.slice(0, filters.serverCount);
            }
            
            if (filteredServers.length === 0) {
                // 데이터 없음 표시
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 8;
                cell.textContent = '표시할 서버가 없습니다.';
                cell.className = 'no-data';
                row.appendChild(cell);
                tableBody.appendChild(row);
                return;
            }
            
            // 테이블에 데이터 추가
            filteredServers.forEach(server => {
                const row = document.createElement('tr');
                
                // 상태에 따른 행 스타일 지정
                if (server.stats.cpuUsage >= 90) {
                    row.className = 'critical';
                } else if (server.stats.cpuUsage >= 70) {
                    row.className = 'warning';
                }
                
                // 셀 추가
                row.innerHTML = `
                    <td>${server.serverName}</td>
                    <td>${server.serverType}</td>
                    <td>${server.location}</td>
                    <td class="centered">${server.stats.cpuUsage.toFixed(1)}%</td>
                    <td class="centered">${server.stats.memoryUsage.toFixed(1)}%</td>
                    <td class="centered">${server.stats.diskUsage.toFixed(1)}%</td>
                    <td>${formatDate(server.timestamp)}</td>
                    <td class="centered">${getStatusBadge(server)}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }
        
        function getStatusBadge(server) {
            // 서버 상태에 따른 배지 생성
            if (server.alerts.some(alert => alert.severity === 'critical')) {
                return '<span class="badge critical">심각</span>';
            } else if (server.alerts.some(alert => alert.severity === 'warning')) {
                return '<span class="badge warning">주의</span>';
            } else {
                return '<span class="badge normal">정상</span>';
            }
        }
        
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return `${date.getFullYear()}-${(date.getMonth()+1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        }
        
        function setupEventListeners() {
            // 필터 변경 이벤트
            document.getElementById('serverTypeFilter').addEventListener('change', function() {
                filters.serverType = this.value;
                updateChartsByFilters();
            });
            
            document.getElementById('locationFilter').addEventListener('change', function() {
                filters.location = this.value;
                updateChartsByFilters();
            });
            
            document.getElementById('thresholdFilter').addEventListener('change', function() {
                filters.threshold = parseInt(this.value);
                updateChartsByFilters();
            });
            
            document.getElementById('serverCountSelect').addEventListener('change', function() {
                filters.serverCount = this.value;
                updateChartsByFilters();
            });
            
            // 상관관계 지표 변경 이벤트
            document.getElementById('correlationMetric').addEventListener('change', function() {
                updateCorrelationChart(this.value);
            });
            
            // 시간 범위 변경 이벤트
            document.getElementById('timeRange').addEventListener('change', updateTimeRange);
            
            // 새로고침 버튼
            document.getElementById('refreshBtn').addEventListener('click', refreshData);
        }
        
        function updateChartsByFilters() {
            // 테이블 업데이트
            updateHighCpuTable();
            
            // 차트 업데이트
            updateTopCpuServersChart();
            
            // 서버 타입이나 위치 필터가 설정된 경우에만 나머지 차트 업데이트
            if (filters.serverType !== 'all' || filters.location !== 'all') {
                updateCpuTrendChartByFilters();
                updateCpuDistributionChartByFilters();
                // 상관관계 차트도 필터 적용 가능
                updateCorrelationChartByFilters();
            }
        }
        
        function updateTopCpuServersChart() {
            if (!topCpuServersChart || !dataProcessor) return;
            
            // 평균 CPU 사용률 가져오기
            const avgCpuByServer = dataProcessor.getAverageCpuUsageByServer();
            
            // 필터 적용
            let filteredServers = Object.keys(avgCpuByServer);
            
            // 서버 유형 필터링
            if (filters.serverType !== 'all') {
                const serversByType = dataProcessor.getServersByType();
                filteredServers = filteredServers.filter(server => 
                    serversByType[filters.serverType] && serversByType[filters.serverType].includes(server));
            }
            
            // 위치 필터링
            if (filters.location !== 'all') {
                const currentStatus = dataProcessor.getCurrentStatusSummary();
                filteredServers = filteredServers.filter(server => 
                    currentStatus[server] && currentStatus[server].location === filters.location);
            }
            
            // CPU 임계값 필터링
            if (filters.threshold > 0) {
                filteredServers = filteredServers.filter(server => avgCpuByServer[server] >= filters.threshold);
            }
            
            // CPU 사용률로 정렬하고 상위 서버 선택
            const serverEntries = filteredServers.map(server => [server, avgCpuByServer[server]]);
            serverEntries.sort((a, b) => b[1] - a[1]); // 내림차순 정렬
            
            let topServers;
            if (filters.serverCount !== 'all' && !isNaN(filters.serverCount)) {
                topServers = serverEntries.slice(0, parseInt(filters.serverCount));
            } else {
                topServers = serverEntries.slice(0, 10); // 기본값
            }
            
            // 데이터가 없는 경우
            if (topServers.length === 0) {
                topCpuServersChart.data.labels = ['데이터 없음'];
                topCpuServersChart.data.datasets[0].data = [0];
                topCpuServersChart.update();
                return;
            }
            
            // 차트 업데이트
            topCpuServersChart.data.labels = topServers.map(entry => entry[0]);
            topCpuServersChart.data.datasets[0].data = topServers.map(entry => entry[1]);
            topCpuServersChart.update();
        }
        
        function updateCpuTrendChartByFilters() {
            if (!cpuTrendChart || !dataProcessor) return;
            
            // 시간별 시스템 상태 가져오기
            const hourlyData = dataProcessor.getHourlySystemStatus();
            
            // 필터를 위한 서버 목록 가져오기
            let filteredServers = [];
            const currentStatus = dataProcessor.getCurrentStatusSummary();
            
            // 서버 유형 필터링
            if (filters.serverType !== 'all') {
                const serversByType = dataProcessor.getServersByType();
                filteredServers = serversByType[filters.serverType] || [];
            } else {
                filteredServers = Object.keys(currentStatus);
            }
            
            // 위치 필터링
            if (filters.location !== 'all') {
                filteredServers = filteredServers.filter(server => 
                    currentStatus[server] && currentStatus[server].location === filters.location);
            }
            
            // 필터링된 서버만의 시간별 데이터 계산
            const filteredHourlyData = hourlyData.map(hour => {
                const serverData = dataProcessor.rawData.filter(record => 
                    filteredServers.includes(record.serverName) && 
                    new Date(record.timestamp).toISOString().startsWith(hour.timestamp.split(' ')[0])
                );
                
                let totalCpu = 0;
                serverData.forEach(record => {
                    totalCpu += record.stats.cpuUsage;
                });
                
                return {
                    timestamp: hour.timestamp,
                    avgCpu: serverData.length > 0 ? totalCpu / serverData.length : 0
                };
            });
            
            // 차트 업데이트
            cpuTrendChart.data.labels = filteredHourlyData.map(hour => hour.timestamp);
            cpuTrendChart.data.datasets[0].data = filteredHourlyData.map(hour => hour.avgCpu);
            cpuTrendChart.update();
        }
        
        function updateCpuDistributionChartByFilters() {
            if (!cpuDistributionChart || !dataProcessor) return;
            
            // 평균 CPU 사용률 가져오기
            const avgCpuByServer = dataProcessor.getAverageCpuUsageByServer();
            
            // 필터 적용
            let filteredServers = Object.keys(avgCpuByServer);
            const currentStatus = dataProcessor.getCurrentStatusSummary();
            
            // 서버 유형 필터링
            if (filters.serverType !== 'all') {
                const serversByType = dataProcessor.getServersByType();
                filteredServers = filteredServers.filter(server => 
                    serversByType[filters.serverType] && serversByType[filters.serverType].includes(server));
            }
            
            // 위치 필터링
            if (filters.location !== 'all') {
                filteredServers = filteredServers.filter(server => 
                    currentStatus[server] && currentStatus[server].location === filters.location);
            }
            
            // CPU 임계값 필터링
            if (filters.threshold > 0) {
                filteredServers = filteredServers.filter(server => avgCpuByServer[server] >= filters.threshold);
            }
            
            // 필터링된 서버의 CPU 값 얻기
            const cpuValues = filteredServers.map(server => avgCpuByServer[server]);
            
            // CPU 사용률 분포 계산 (0-10%, 10-20%, ...)
            const distribution = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 10개 구간
            cpuValues.forEach(value => {
                const index = Math.min(9, Math.floor(value / 10));
                distribution[index]++;
            });
            
            // 차트 업데이트
            cpuDistributionChart.data.datasets[0].data = distribution;
            cpuDistributionChart.update();
        }
        
        function updateCorrelationChartByFilters() {
            if (!correlationChart || !dataProcessor) return;
            
            // 현재 선택된 비교 지표
            const metric = document.getElementById('correlationMetric').value;
            
            // 현재 상태 요약 가져오기
            const currentStatus = dataProcessor.getCurrentStatusSummary();
            
            // 필터 적용
            let filteredServers = Object.values(currentStatus);
            
            // 서버 유형 필터링
            if (filters.serverType !== 'all') {
                filteredServers = filteredServers.filter(server => server.serverType === filters.serverType);
            }
            
            // 위치 필터링
            if (filters.location !== 'all') {
                filteredServers = filteredServers.filter(server => server.location === filters.location);
            }
            
            // CPU 임계값 필터링
            if (filters.threshold > 0) {
                filteredServers = filteredServers.filter(server => server.stats.cpuUsage >= filters.threshold);
            }
            
            // 데이터 포인트 준비
            const dataPoints = [];
            
            filteredServers.forEach(server => {
                let yValue = 0;
                
                switch(metric) {
                    case 'memory':
                        yValue = server.stats.memoryUsage;
                        break;
                    case 'disk':
                        yValue = server.stats.diskUsage;
                        break;
                    case 'network':
                        yValue = server.stats.networkUsage || 0;
                        break;
                    case 'requests':
                        yValue = server.stats.requestsPerMinute || 0;
                        break;
                }
                
                dataPoints.push({
                    x: server.stats.cpuUsage,
                    y: yValue,
                    serverName: server.serverName,
                    serverType: server.serverType,
                    location: server.location
                });
            });
            
            // 차트 업데이트
            correlationChart.data.datasets[0].data = dataPoints;
            correlationChart.update();
            
            // 상관계수 업데이트
            updateCorrelationAnalysis(metric, dataPoints);
        }
        
        function updateCorrelationChart(metric) {
            if (!correlationChart || !dataProcessor) return;
            
            // 현재 상태 요약 가져오기
            const currentStatus = dataProcessor.getCurrentStatusSummary();
            
            // 필터 적용
            let filteredServers = Object.values(currentStatus);
            
            // 서버 유형 필터링
            if (filters.serverType !== 'all') {
                filteredServers = filteredServers.filter(server => server.serverType === filters.serverType);
            }
            
            // 위치 필터링
            if (filters.location !== 'all') {
                filteredServers = filteredServers.filter(server => server.location === filters.location);
            }
            
            // CPU 임계값 필터링
            if (filters.threshold > 0) {
                filteredServers = filteredServers.filter(server => server.stats.cpuUsage >= filters.threshold);
            }
            
            // 선택된 지표에 따라 데이터 준비
            let yAxisLabel = '';
            const dataPoints = [];
            
            filteredServers.forEach(server => {
                let yValue = 0;
                
                switch(metric) {
                    case 'memory':
                        yValue = server.stats.memoryUsage;
                        yAxisLabel = '메모리 사용률 (%)';
                        break;
                    case 'disk':
                        yValue = server.stats.diskUsage;
                        yAxisLabel = '디스크 사용률 (%)';
                        break;
                    case 'network':
                        yValue = server.stats.networkUsage || 0; // 데이터에 없을 수 있음
                        yAxisLabel = '네트워크 트래픽 (Mbps)';
                        break;
                    case 'requests':
                        yValue = server.stats.requestsPerMinute || 0; // 데이터에 없을 수 있음
                        yAxisLabel = '분당 요청 수';
                        break;
                }
                
                dataPoints.push({
                    x: server.stats.cpuUsage,
                    y: yValue,
                    serverName: server.serverName,
                    serverType: server.serverType,
                    location: server.location
                });
            });
            
            // 차트 업데이트
            correlationChart.data.datasets[0].label = `CPU vs ${yAxisLabel}`;
            correlationChart.data.datasets[0].data = dataPoints;
            correlationChart.options.scales.y.title.text = yAxisLabel;
            
            // 툴팁 콜백 업데이트
            correlationChart.options.plugins.tooltip.callbacks.label = function(context) {
                const dataPoint = context.raw;
                return [
                    `서버: ${dataPoint.serverName}`,
                    `유형: ${dataPoint.serverType}`,
                    `위치: ${dataPoint.location}`,
                    `CPU: ${dataPoint.x.toFixed(1)}%`,
                    `${metric === 'memory' ? '메모리' : metric === 'disk' ? '디스크' : metric === 'network' ? '네트워크' : '요청'}: ${dataPoint.y.toFixed(1)}${metric === 'network' ? 'Mbps' : metric === 'requests' ? '/분' : '%'}`
                ];
            };
            
            correlationChart.update();
            
            // 상관계수 업데이트
            updateCorrelationAnalysis(metric, dataPoints);
        }
        
        function updateCorrelationAnalysis(metric, dataPoints = null) {
            if (!dataProcessor) return;
            
            // 데이터 포인트가 제공되지 않은 경우 새로 계산
            if (!dataPoints) {
                const currentStatus = dataProcessor.getCurrentStatusSummary();
                
                dataPoints = Object.values(currentStatus).map(server => {
                    let yValue = 0;
                    
                    switch(metric) {
                        case 'memory':
                            yValue = server.stats.memoryUsage;
                            break;
                        case 'disk':
                            yValue = server.stats.diskUsage;
                            break;
                        case 'network':
                            yValue = server.stats.networkUsage || 0;
                            break;
                        case 'requests':
                            yValue = server.stats.requestsPerMinute || 0;
                            break;
                    }
                    
                    return {
                        x: server.stats.cpuUsage,
                        y: yValue
                    };
                });
            }
            
            // 상관계수 계산
            const n = dataPoints.length;
            
            if (n <= 1) {
                document.getElementById('correlationCoefficient').textContent = '데이터 부족';
                document.getElementById('correlationAnalysis').textContent = '분석할 충분한 데이터가 없습니다.';
                return;
            }
            
            const sumX = dataPoints.reduce((sum, point) => sum + point.x, 0);
            const sumY = dataPoints.reduce((sum, point) => sum + point.y, 0);
            const sumXY = dataPoints.reduce((sum, point) => sum + (point.x * point.y), 0);
            const sumX2 = dataPoints.reduce((sum, point) => sum + (point.x ** 2), 0);
            const sumY2 = dataPoints.reduce((sum, point) => sum + (point.y ** 2), 0);
            
            const numerator = (n * sumXY) - (sumX * sumY);
            const denominator = Math.sqrt(((n * sumX2) - (sumX ** 2)) * ((n * sumY2) - (sumY ** 2)));
            
            let correlationCoefficient = 0;
            
            if (denominator !== 0) {
                correlationCoefficient = numerator / denominator;
            }
            
            // 결과 표시
            document.getElementById('correlationCoefficient').textContent = correlationCoefficient.toFixed(3);
            
            // 분석 결과 생성
            let analysisText = '';
            const absCC = Math.abs(correlationCoefficient);
            
            if (absCC >= 0.7) {
                if (correlationCoefficient > 0) {
                    analysisText = `CPU 사용률과 ${getMetricName(metric)} 사이에 강한 양의 상관관계가 있습니다. CPU 사용률이 증가하면 ${getMetricName(metric)}도 크게 증가합니다.`;
                } else {
                    analysisText = `CPU 사용률과 ${getMetricName(metric)} 사이에 강한 음의 상관관계가 있습니다. CPU 사용률이 증가하면 ${getMetricName(metric)}은 크게 감소합니다.`;
                }
            } else if (absCC >= 0.4) {
                if (correlationCoefficient > 0) {
                    analysisText = `CPU 사용률과 ${getMetricName(metric)} 사이에 중간 정도의 양의 상관관계가 있습니다. CPU 사용률이 증가하면 ${getMetricName(metric)}도 어느 정도 증가합니다.`;
                } else {
                    analysisText = `CPU 사용률과 ${getMetricName(metric)} 사이에 중간 정도의 음의 상관관계가 있습니다. CPU 사용률이 증가하면 ${getMetricName(metric)}은 어느 정도 감소합니다.`;
                }
            } else {
                analysisText = `CPU 사용률과 ${getMetricName(metric)} 사이에 뚜렷한 상관관계가 보이지 않습니다. 다른 요인들이 더 큰 영향을 미칠 수 있습니다.`;
            }
            
            document.getElementById('correlationAnalysis').textContent = analysisText;
        }
        
        function getMetricName(metric) {
            switch(metric) {
                case 'memory': return '메모리 사용률';
                case 'disk': return '디스크 사용률';
                case 'network': return '네트워크 트래픽';
                case 'requests': return '요청 수';
                default: return metric;
            }
        }
        
        function updateTimeRange() {
            const hours = parseInt(document.getElementById('timeRange').value);
            
            // 실제로는 서버에서 새로운 데이터를 가져와야 함
            // 데모에서는 기존 데이터의 일부만 사용하여 시뮬레이션
            
            // 로딩 표시
            showLoading();
            
            setTimeout(() => {
                try {
                    // 시간별 시스템 상태 가져오기
                    const hourlyData = dataProcessor.getHourlySystemStatus();
                    
                    // 선택된 시간 범위에 따라 데이터 필터링
                    const recentData = hourlyData.slice(-hours);
                    
                    // CPU 추세 차트 업데이트
                    if (cpuTrendChart) {
                        cpuTrendChart.data.labels = recentData.map(hour => hour.timestamp);
                        cpuTrendChart.data.datasets[0].data = recentData.map(hour => hour.avgCpu);
                        cpuTrendChart.update();
                    }
                    
                    // 필터 적용된 테이블 업데이트
                    updateHighCpuTable();
                    
                } catch (error) {
                    console.error('시간 범위 업데이트 중 오류 발생:', error);
                    showError('시간 범위를 변경하는 중 오류가 발생했습니다.');
                } finally {
                    hideLoading();
                }
            }, 500);
        }
        
        function refreshData() {
            // 로딩 표시
            showLoading();
            
            // 실제로는 서버에서 새로운 데이터를 가져와야 함
            // 데모에서는 시간 지연 후 화면 업데이트로 시뮬레이션
            setTimeout(() => {
                try {
                    // 필터 적용된 테이블 업데이트
                    updateHighCpuTable();
                    
                    // 차트 업데이트
                    if (topCpuServersChart) {
                        updateTopCpuServersChart();
                    }
                    
                } catch (error) {
                    console.error('데이터 새로고침 중 오류 발생:', error);
                    showError('데이터를 새로고침하는 중 오류가 발생했습니다.');
                } finally {
                    hideLoading();
                }
            }, 500);
        }
        
        function showLoading() {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.style.display = 'flex';
            }
        }
        
        function hideLoading() {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.style.display = 'none';
            }
        }
        
        function showError(message) {
            const errorElement = document.getElementById('error-message');
            if (errorElement) {
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // 일정 시간 후 숨기기
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 5000);
            }
        }
        
        // 페이지 로드 시 초기화
        window.addEventListener('DOMContentLoaded', initPage);
