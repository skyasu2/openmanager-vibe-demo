<script src="fixed_dummy_data.js"></script> <script src="data_processor.js"></script>
<script>
    let allServerDataForCpuAnalysis = [];
    let dataProcessor; // 이 페이지용 dataProcessor 인스턴스
    // ... (기존 차트 변수들) ...

    async function initPage() { // async는 이제 필수는 아님
        try {
            showLoading();
            // HTML에서 fixed_dummy_data.js가 먼저 로드되었다고 가정
            if (typeof getFixedDummyData !== 'function') {
                 console.error("getFixedDummyData is not defined!"); // 오류 로깅
                 showError("필수 데이터 파일을 로드할 수 없습니다.");
                 hideLoading();
                 return;
            }
            allServerDataForCpuAnalysis = getFixedDummyData();

            if (!allServerDataForCpuAnalysis || allServerDataForCpuAnalysis.length === 0) {
                showError("서버 데이터를 로드할 수 없습니다.");
                hideLoading();
                return;
            }
            
            dataProcessor = new ServerDataProcessor(allServerDataForCpuAnalysis);
            
            initializeFilters(); // 필터 초기화 (serverType, location 등)
            initializeCharts();  // 차트 초기화
            updateHighCpuTable(); // 테이블 업데이트
            setupEventListeners();
            hideLoading();
        } catch (error) {
            console.error('페이지 초기화 중 오류 발생:', error);
            showError("페이지를 초기화하는 중 오류가 발생했습니다.");
            hideLoading();
        }
    }

    // loadServerData 함수는 삭제합니다.

    // initializeFilters 함수에서 서버 유형, 위치 등을 가져올 때
    // dataProcessor.getServersByType(), dataProcessor.getStatusByLocation() 등이
    // 새 데이터 구조를 기반으로 동작해야 합니다. (data_processor.js 수정 필요)
    function initializeFilters() {
        const serverTypes = Object.keys(dataProcessor.getServersByType()); // data_processor.js 수정 필요
        const serverTypeFilter = document.getElementById('serverTypeFilter');
        serverTypes.forEach(type => { /* ... 옵션 추가 ... */ });

        // 위치 정보는 현재 fixed_dummy_data에 없으므로, 해당 필터는 비활성화하거나 serverType 등으로 대체 필요
        // const locations = Object.keys(dataProcessor.getStatusByLocation()); // data_processor.js 수정 필요
        // const locationFilter = document.getElementById('locationFilter');
        // locations.forEach(location => { /* ... 옵션 추가 ... */ });
        // 임시로 locationFilter는 비워두거나 다른 기준으로 채울 수 있습니다.
        document.getElementById('locationFilter').innerHTML = '<option value="all">모든 위치 (N/A)</option>';

        filters.serverCount = parseInt(document.getElementById('serverCountSelect').value);
        if (isNaN(filters.serverCount)) filters.serverCount = 10;
    }


    // 모든 차트 생성 함수 (initCpuTrendChart, initCpuByTypeChart 등)와
    // 테이블 업데이트 함수 (updateHighCpuTable) 내부에서
    // dataProcessor의 메소드 (getHourlySystemStatus, getServersByType, getAverageCpuUsageByServer 등)를
    // 호출할 때, 해당 메소드들이 새 데이터 구조(stats.cpuUsage, serverHostname 등)를
    // 올바르게 처리하도록 data_processor.js 내부에서 수정되었다고 가정합니다.

    // 예시: updateHighCpuTable
    function updateHighCpuTable() {
        const tableBody = document.querySelector('#highCpuTable tbody');
        tableBody.innerHTML = '';
        
        // getCurrentStatusSummary는 각 서버의 최신 상태를 반환해야 함
        const currentStatusSummary = dataProcessor.getCurrentStatusSummary(); 
        let filteredServers = Object.values(currentStatusSummary);

        // 필터링 로직 ... (serverType, location - 현재는 없음, threshold)
        if (filters.serverType !== 'all') {
            filteredServers = filteredServers.filter(server => server.serverType === filters.serverType);
        }
        // 위치 필터는 현재 데이터에 없으므로 생략하거나 수정 필요
        // if (filters.location !== 'all') { ... } 
        if (filters.threshold > 0) {
            filteredServers = filteredServers.filter(server => server.stats.cpuUsage >= filters.threshold);
        }
        
        filteredServers.sort((a, b) => b.stats.cpuUsage - a.stats.cpuUsage);
        
        if (filters.serverCount !== 'all' && !isNaN(filters.serverCount)) {
             filteredServers = filteredServers.slice(0, parseInt(filters.serverCount));
        }


        if (filteredServers.length === 0) { /* ... 데이터 없음 표시 ... */ return; }
        
        filteredServers.forEach(server => { // server 객체는 fixed_dummy_data의 구조
            const row = document.createElement('tr');
            // 상태에 따른 행 스타일 (server.status 사용)
            if (server.status === 'Critical') row.className = 'critical';
            else if (server.status === 'Warning') row.className = 'warning';
            
            row.innerHTML = `
                <td>${server.serverHostname}</td>
                <td>${server.serverType}</td>
                <td class="centered">${server.stats.cpuUsage.toFixed(1)}%</td>
                <td class="centered">${server.stats.memoryUsage.toFixed(1)}%</td>
                <td class="centered">${server.stats.diskUsage.toFixed(1)}%</td>
                <td>${formatDate(server.timestamp)}</td>
                <td class="centered">${getStatusBadge(server)}</td>
            `;
            tableBody.appendChild(row);
        });
    }

    function getStatusBadge(server) { // server는 fixed_dummy_data 항목
        if (server.status === 'Critical') {
            return '<span class="badge critical">심각</span>';
        } else if (server.status === 'Warning') {
            return '<span class="badge warning">주의</span>';
        } else {
            return '<span class="badge normal">정상</span>';
        }
    }

    // updateCorrelationChart 등 다른 함수들도 dataProcessor를 통해
    // 새 데이터 구조를 사용하는지 확인이 필요합니다.
    // ... (나머지 함수들) ...
    window.addEventListener('DOMContentLoaded', initPage);
</script>
</body>
</html>
