<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenManager 7.0 - 자연어 기반 서버 분석</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body { font-family: 'Malgun Gothic', 'Segoe UI', sans-serif; margin: 0; padding: 0; color: #333; background-color: #f5f7fa; }
        .header { background-color: #2c3e50; color: white; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; }
        .logo { font-size: 20px; font-weight: bold; }
        .nav-menu { display: flex; }
        .nav-item { padding: 8px 15px; margin-left: 5px; color: white; text-decoration: none; border-radius: 4px; }
        .nav-item.active { background-color: #3498db; }
        .container { max-width: 1300px; margin: 20px auto; padding: 20px; background-color: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #2c3e50; }
        h1 { text-align: center; margin-bottom: 5px;}
        h2 { border-bottom: 1px solid #eee; padding-bottom: 10px; margin-top: 30px; margin-bottom: 20px; font-size: 1.3em; }
        .timestamp { text-align: center; color: #7f8c8d; margin-bottom: 25px; font-size: 0.9em; }
        
        .nlp-section { background-color: #eaf5ff; padding: 20px; border-radius: 6px; margin-bottom: 25px; border: 1px solid #cce0ff;}
        .nlp-section h3 { margin-top: 0; color: #0056b3; border-bottom-color: #add8e6; }
        .nlp-input-group { display: flex; gap: 10px; margin-bottom: 10px; align-items: center;}
        #nlp-query-input { flex-grow: 1; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.95em;}
        #nlp-query-select { padding: 10px; border: 1px solid #ced4da; border-radius: 4px; background-color: white; font-size: 0.95em; min-width: 250px; }
        #nlp-submit-btn { padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; font-size: 0.95em;}
        #nlp-submit-btn:hover { background-color: #0056b3; }
        .nlp-result-explanation { background-color: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.85em; color: #495057; margin-bottom: 15px; border: 1px dashed #ced4da;}
        
        .filters-section { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 25px; padding: 15px; background-color: #f9f9f9; border-radius: 6px; align-items: center; }
        .filter-group { display: flex; flex-direction: column; }
        .filter-group label { font-size: 0.85em; margin-bottom: 5px; color: #555; }
        .filter-select { padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; background-color: white; min-width: 160px; }
        .filter-btn { padding: 9px 18px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; height: 38px; align-self: flex-end; }
        .filter-btn:hover { background-color: #2980b9; }

        .resource-sections-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .resource-section, .problem-section, .nlp-summary-section { background-color: #fff; padding: 15px 20px; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.08); border: 1px solid #e9ecef; }
        .resource-section h3, .problem-section h3, .nlp-summary-section h3 { margin-top: 0; margin-bottom: 15px; color: #34495e; border-bottom: 2px solid #3498db; padding-bottom: 10px; font-size: 1.1em; font-weight: 600; }
        
        .server-list-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 5px; border-bottom: 1px dashed #ecf0f1; font-size: 0.9em; transition: background-color 0.2s ease-in-out; }
        .server-list-item:hover { background-color: #f8f9fa; }
        .server-list-item:last-child { border-bottom: none; }
        .server-name { font-weight: 600; color: #2c3e50; flex-basis: 55%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .server-name[title] { cursor: help; }
        .server-usage { color: #2980b9; font-weight: 500; flex-basis: 40%; text-align: right; }
        
        .problem-item .server-name, .nlp-summary-item .server-name { display: block; margin-bottom: 3px;}
        .problem-item .server-alerts, .nlp-summary-item .server-details { font-size: 0.8em; color: #7f8c8d; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; display: block; }
        .nlp-summary-item .server-details { color: #555; } 
        .problem-item .server-alerts[title], .nlp-summary-item .server-details[title] { cursor: help; }
        .problem-item .problem-score, .nlp-summary-item .nlp-relevance-score { font-size: 0.95em; color: #e74c3c; font-weight: bold; white-space: nowrap; }
        .problem-item, .nlp-summary-item { cursor: pointer; }

        .report-button { background-color: #17a2b8; color: white; padding: 6px 12px; font-size: 0.8em; border:none; border-radius: 4px; cursor: pointer; margin-top: 8px; display: inline-block;}
        .report-button:hover { background-color: #138496; }

        .modal { display: none; position: fixed; z-index: 10001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); }
        .modal-content { background-color: #fefefe; margin: 10% auto; padding: 25px; border: 1px solid #888; width: 70%; max-width: 800px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); position: relative; }
        .modal-close { color: #aaa; float: right; font-size: 28px; font-weight: bold; position: absolute; top: 10px; right: 20px; }
        .modal-close:hover, .modal-close:focus { color: black; text-decoration: none; cursor: pointer; }
        .modal-content h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom:10px; }
        .modal-content pre { background-color: #f8f9fa; padding: 15px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; max-height: 400px; overflow-y: auto; }

        .csv-btn { margin-top: 20px; display: inline-block; padding: 10px 20px; background-color: #2ecc71; color: white; text-decoration: none; border-radius: 4px; font-size: 0.9em; cursor: pointer; border: none; transition: background-color 0.3s; }
        .csv-btn:hover { background-color: #27ae60; }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.85); display: none; justify-content: center; align-items: center; z-index: 10000; }
        .loading-spinner { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <div id="report-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="modal-close-btn">&times;</span>
            <h4 id="report-title">분석 보고서</h4>
            <div id="report-body">
                <pre id="report-text-content"></pre>
            </div>
        </div>
    </div>

    <header class="header">
        <div class="logo">OpenManager 7.0</div>
        <nav class="nav-menu">
            <a href="index.html" class="nav-item">소개</a>
            <a href="demo.html" class="nav-item active">자연어 기반 서버 분석</a>
        </nav>
    </header>

    <div class="container">
        <h1>자연어 기반 서버 분석</h1>
        <div class="timestamp" id="timestamp">데이터 기준 시각: 로딩 중...</div>

        <section class="nlp-section">
            <h3>질의를 통해 서버 경고 요약하기</h3>
            <div class="nlp-input-group">
                <input type="text" id="nlp-query-input" placeholder="예: CPU 사용률 높은 서버 찾아줘">
                <select id="nlp-query-select">
                    <option value="">-- 예시 질문 선택 --</option>
                    <option data-report-type="cpu_threshold" value="CPU 사용률이 80% 이상인 서버 목록 보여줘">CPU 80% 이상 서버</option>
                    <option data-report-type="memory_leak_was" value="메모리 사용량이 지속적으로 높은 WAS 서버는?">메모리 누수 의심 WAS</option>
                    <option data-report-type="disk_critical_db" value="디스크 공간 90% 이상 사용 중인 DB 서버">디스크 부족 DB 서버</option>
                    <option data-report-type="network_top_api_6h" value="지난 6시간 동안 네트워크 트래픽(Out)이 가장 많았던 API 서버">6시간 내 트래픽 TOP API 서버</option>
                    <option data-report-type="critical_location_cause" value="Seoul-IDC에서 Critical 상태인 모든 서버와 그 원인">서울IDC Critical 서버 원인</option>
                    <option data-report-type="application_orderservice_error" value="'OrderService' 애플리케이션 오류가 발생한 서버와 시간">OrderService 오류 서버/시간</option>
                    <option data-report-type="security_login_fail_24h" value="최근 24시간 내 로그인 실패(Security) 경고가 있었던 서버는?">24시간 내 로그인 실패 경고</option>
                    <option data-report-type="batch_job_yesterday" value="어제 실행된 BATCH 서버들의 작업 상태 요약">어제 BATCH 작업 상태</option>
                    <option data-report-type="critical_error_today" value="오늘 발생한 모든 Critical 및 Error 경고 요약">오늘 주요 경고 요약</option>
                </select>
                <button id="nlp-submit-btn">질의 실행</button>
            </div>
            <div class="nlp-result-explanation" id="nlp-explanation">
                <strong>해석된 조건:</strong> (여기에 자연어 질의 해석 결과가 표시됩니다)
            </div>
        </section>

        <section class="nlp-summary-section">
            <h3>자연어 질의 결과 요약</h3>
            <div id="nlp-summary-list">
                </div>
            <div id="nlp-report-button-container" style="margin-top: 15px; text-align: right;">
                </div>
        </section>

        <hr style="margin: 30px 0;">

        <h2>기존 필터 기반 분석 (참고용)</h2>
        <div class="filters-section">
            <div class="filter-group">
                <label for="time-filter">시간 범위:</label>
                <select class="filter-select" id="time-filter">
                    <option value="1">최근 1시간</option> <option value="6">최근 6시간</option>
                    <option value="24" selected>최근 24시간</option> <option value="72">최근 3일</option>
                    <option value="168">최근 7일</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="server-type-filter">서버 유형:</label>
                <select class="filter-select" id="server-type-filter">
                    <option value="all">모든 서버 유형</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="location-filter">위치:</label>
                <select class="filter-select" id="location-filter">
                    <option value="all">모든 위치</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="alert-filter">문제 분석용 경고 필터:</label>
                <select class="filter-select" id="alert-filter">
                    <option value="all">모든 경고 (문제분석용)</option>
                    <option value="Critical">심각(Critical)만</option>
                    <option value="Error">오류(Error)만</option>
                    <option value="Warning">주의(Warning)만</option>
                </select>
            </div>
            <button class="filter-btn" id="apply-filter-btn">필터 적용 (참고용)</button>
        </div>

        <h2>리소스 사용률 TOP 5 (참고용)</h2>
        <div class="resource-sections-grid">
            <div class="resource-section" id="cpu-top-section"><h3>CPU 사용률 TOP 5</h3><div id="cpu-top-list"></div></div>
            <div class="resource-section" id="memory-top-section"><h3>메모리 사용률 TOP 5</h3><div id="memory-top-list"></div></div>
            <div class="resource-section" id="disk-top-section"><h3>디스크 사용률 TOP 5</h3><div id="disk-top-list"></div></div>
            <div class="resource-section" id="network-top-section"><h3>네트워크 트래픽 TOP 5</h3><div id="network-top-list"></div></div>
        </div>

        <div class="problem-section">
            <h3>주요 문제 발생 서버 TOP 5 (필터 기반 분석 결과)</h3>
            <div id="problematic-servers-list"></div>
        </div>

        <button class="csv-btn" id="download-csv-btn">종합 요약 CSV 다운로드</button>

    </div>

    <script src="fixed_dummy_data.js"></script>
    <script src="data_processor.js"></script>
    <script>
        // --- 전역 변수 및 기본 함수 ---
        let allServerData = [];
        let dataProcessor = null;
        const loadingOverlay = document.getElementById('loading-overlay');
        const reportModal = document.getElementById('report-modal');
        const reportTitleEl = document.getElementById('report-title');
        const reportTextContentEl = document.getElementById('report-text-content');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        function showLoading() { if (loadingOverlay) loadingOverlay.style.display = 'flex'; }
        function hideLoading() { if (loadingOverlay) loadingOverlay.style.display = 'none'; }

        function populateDropdown(selectElement, optionsArray, defaultOptionText) {
            if (!selectElement) { console.error("Dropdown element not found for: " + defaultOptionText); return; }
            selectElement.innerHTML = `<option value="all">${defaultOptionText}</option>`;
            (optionsArray || []).forEach(optionValue => {
                const option = document.createElement('option');
                option.value = optionValue; option.textContent = optionValue;
                selectElement.appendChild(option);
            });
        }
        
        function initializeLegacyFilters() {
            if (!dataProcessor) { console.error("DataProcessor not ready for initializing filters."); return; }
            populateDropdown(document.getElementById('server-type-filter'), dataProcessor.getUniqueServerTypes(), '모든 서버 유형');
            populateDropdown(document.getElementById('location-filter'), dataProcessor.getUniqueLocations(), '모든 위치');
            
            const alertFilterEl = document.getElementById('alert-filter');
            const uniqueAlertTypes = dataProcessor.getUniqueAlertTypes();
            if (alertFilterEl && uniqueAlertTypes) {
                uniqueAlertTypes.forEach(alertType => {
                    if (!['Critical', 'Error', 'Warning', 'Info'].includes(alertType)) {
                        const option = document.createElement('option');
                        option.value = alertType; option.textContent = `${alertType} 관련 경고`;
                        alertFilterEl.appendChild(option);
                    }
                });
            }
        }

        function renderTopResourceList(listElementId, servers) {
            const listElement = document.getElementById(listElementId);
            if (!listElement) { console.error(`Element with ID '${listElementId}' not found.`); return; }
            listElement.innerHTML = '';
            if (!servers || servers.length === 0) {
                listElement.innerHTML = '<p style="font-size:0.85em; color:#777; text-align:center; padding-top:20px;">데이터 없음</p>';
                return;
            }
            servers.forEach(server => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'server-list-item';
                itemDiv.innerHTML = `
                    <span class="server-name" title="타입: ${server.type || 'N/A'} | 위치: ${server.location || 'N/A'}">${(server.name || 'N/A').split('.')[0]}</span>
                    <span class="server-usage">${(server.avgUsage !== undefined ? server.avgUsage.toFixed(1) : 'N/A')}${server.unit || ''}</span>
                `;
                listElement.appendChild(itemDiv);
            });
        }

        function renderProblematicServersList(servers) {
             const listElement = document.getElementById('problematic-servers-list');
            if (!listElement) { console.error("Element with ID 'problematic-servers-list' not found."); return; }
            listElement.innerHTML = '';
            if (!servers || servers.length === 0) {
                listElement.innerHTML = '<p style="font-size:0.85em; color:#777; text-align:center; padding-top:20px;">주요 문제 발생 서버 없음</p>';
                return;
            }
            servers.forEach(server => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'server-list-item problem-item';
                itemDiv.innerHTML = `
                    <div>
                        <span class="server-name" title="타입: ${server.type || 'N/A'} | 위치: ${server.location || 'N/A'}">${(server.name || 'N/A').split('.')[0]}</span>
                        <div class="server-alerts" title="${server.recentProblemMessages || ''}">${server.recentProblemMessages || '상세 정보 확인 필요'}</div>
                    </div>
                    <span class="problem-score">Score: ${server.score || 0} (C:${server.criticalAlertCount || 0}/E:${server.errorAlertCount || 0}/W:${server.warningAlertCount || 0})</span>
                `;
                itemDiv.addEventListener('click', () => {
                    alert(`서버: ${server.name || 'N/A'}\n타입: ${server.type || 'N/A'}\n위치: ${server.location || 'N/A'}\n문제 점수: ${server.score || 0}\n최근 문제 요약: ${server.recentProblemMessages || '없음'}`);
                });
                listElement.appendChild(itemDiv);
            });
        }
        function renderNLPSummaryList(servers, query, detectedReportType) {
            const resultListEl = document.getElementById('nlp-summary-list');
            const reportButtonContainer = document.getElementById('nlp-report-button-container');
            if (!resultListEl || !reportButtonContainer) { console.error("NLP result/button container not found."); return;}

            resultListEl.innerHTML = '';
            reportButtonContainer.innerHTML = ''; 

            if (!servers || servers.length === 0) {
                resultListEl.innerHTML = `<p style="font-size:0.85em; color:#777;">"${query}"에 대한 요약 결과가 없습니다.</p>`;
            } else {
                servers.forEach(server => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'server-list-item nlp-summary-item';
                    itemDiv.innerHTML = `
                        <div>
                            <span class="server-name" title="타입: ${server.type || 'N/A'} | 위치: ${server.location || 'N/A'}">${(server.name || 'N/A').split('.')[0]}</span>
                            <div class="server-details" title="${server.recentProblemMessages || ''}">${server.recentProblemMessages || '문제 상세 정보 없음'}</div>
                        </div>
                        <span class="nlp-relevance-score">분석점수: ${server.score || 0}</span>
                    `;
                    itemDiv.addEventListener('click', () => alert(`서버: ${server.name}\n문제 점수: ${server.score}\n상세: ${server.recentProblemMessages}`));
                    resultListEl.appendChild(itemDiv);
                });

                const reportButton = document.createElement('button');
                reportButton.className = 'report-button';
                reportButton.textContent = `${detectedReportType.replace(/_/g, ' ').toUpperCase()} 분석 보고서 생성`;
                reportButton.onclick = function() {
                    const report = generatePredefinedReport(detectedReportType, query, servers); 
                    showReportModal(report.title, report.content);
                };
                reportButtonContainer.appendChild(reportButton);
            }
        }
        function showReportModal(title, content) {
            if (reportModal && reportTitleEl && reportTextContentEl) {
                reportTitleEl.textContent = title;
                reportTextContentEl.textContent = content; 
                reportModal.style.display = "block";
            } else {
                console.error("Report modal elements not found.");
            }
        }

        function generatePredefinedReport(reportType, query, nlpSummaryData) {
            let reportTitle = "분석 보고서";
            let reportContent = `[원본 질의] "${query}"\n========================================\n\n`;
            const affectedServersFromNlp = nlpSummaryData && nlpSummaryData.length > 0 ? nlpSummaryData : [];
            const topProblemServer = affectedServersFromNlp.length > 0 ? affectedServersFromNlp[0] : null;
            const topN = 3;
            const getResourceTopNString = (resourceKey, unit, dataToProcess = allServerData) => {
                if (!dataProcessor || !dataToProcess || dataToProcess.length === 0) return "데이터 프로세서 미초기화 또는 데이터 없음\n";
                const topServers = dataProcessor.getTopNServersByResource(dataToProcess, resourceKey, topN);
                let str = "";
                if (topServers && topServers.length > 0) {
                    topServers.forEach((s, idx) => {
                        str += `${idx + 1}. ${s.name.split('.')[0]} (${s.type}, ${s.location}): 평균 ${s.avgUsage.toFixed(1)}${unit}\n`;
                    });
                } else { str = `관련 서버 정보 없음 (리소스: ${resourceKey})\n`; }
                return str;
            };
            const getQueryRelatedServerInfoString = () => {
                if (topProblemServer && topProblemServer.name) {
                    return `[질의 관련 주요 서버 분석]\n` +
                           `- 서버: ${topProblemServer.name} (유형: ${topProblemServer.type}, 위치: ${topProblemServer.location})\n` +
                           `- 분석 점수: ${topProblemServer.score} (C:${topProblemServer.criticalAlertCount}, E:${topProblemServer.errorAlertCount}, W:${topProblemServer.warningAlertCount})\n` +
                           `- 주요 경고/문제: ${topProblemServer.recentProblemMessages}\n\n`;
                }
                return "질의와 직접 관련된 주요 문제 서버 정보가 명확하지 않거나, 여러 서버에 걸친 일반적인 상황일 수 있습니다.\n\n";
            };
            reportContent += getQueryRelatedServerInfoString();

            switch(reportType.toLowerCase()) {
                case 'cpu_threshold': case 'cpu_high': case 'cpu':
                    reportTitle = "CPU 사용률 상세 분석 보고서";
                    reportContent += "[상세 분석 및 권고]\nCPU 사용률이 비정상적으로 높은 것은 시스템 성능 저하의 주요 원인이 됩니다.\n\n";
                    reportContent += `[전체 기간 CPU 사용률 TOP${topN} 서버 (평균)]\n${getResourceTopNString('cpu', '%')}`;
                    reportContent += "\n[조치 권고 사항]\n1. 실시간 모니터링을 통해 현재 CPU를 많이 사용하는 프로세스를 식별합니다.\n2. 해당 서버의 시스템 및 애플리케이션 로그에서 과도한 CPU 사용과 관련된 오류나 경고를 확인합니다.\n3. 특정 애플리케이션, 백그라운드 작업, 비효율적인 쿼리 등 원인을 다각도로 분석합니다.\n4. 코드 최적화, 불필요한 프로세스 정리, 스케줄링 조정 등을 수행합니다.\n5. 지속적인 고부하 시 서버 스펙 업그레이드 또는 부하 분산을 고려합니다.";
                    break;
                case 'memory_leak_was': case 'memory':
                    reportTitle = "메모리 사용 현황 및 누수 의심 분석 보고서";
                    reportContent += "[상세 분석 및 권고]\n메모리 사용량이 지속적으로 높거나 급증하는 현상은 메모리 누수 또는 부족을 의미할 수 있습니다.\n\n";
                    reportContent += `[전체 기간 메모리 사용률 TOP${topN} 서버 (평균)]\n${getResourceTopNString('memory', '%')}`;
                    reportContent += "\n[조치 권고 사항]\n1. 시간대별 메모리 사용량 변화 추이를 관찰하여 비정상적인 증가 패턴을 확인합니다.\n2. JVM Heap Dump 분석, GC 로그 분석(Java의 경우) 또는 해당 언어 프로파일링 도구를 사용하여 누수 지점을 찾습니다.\n3. 애플리케이션 및 시스템의 메모리 관련 설정(예: JVM Heap Size, DB 버퍼 풀)을 검토하고 최적화합니다.\n4. 장시간 사용되지 않거나 불필요하게 큰 메모리를 차지하는 객체 및 캐시를 정리합니다.";
                    break;
                case 'disk_critical_db': case 'disk':
                    reportTitle = "디스크 공간 및 I/O 분석 보고서";
                    reportContent += "[상세 분석 및 권고]\n디스크 공간 부족은 서비스 중단을, I/O 병목은 성능 저하를 야기합니다.\n\n";
                    reportContent += `[전체 기간 디스크 사용률 TOP${topN} 서버 (평균)]\n${getResourceTopNString('disk', '%')}`;
                    reportContent += "\n[조치 권고 사항]\n1. 'df', 'du' 명령으로 용량 확인 후 불필요한 파일(로그, 백업, 임시 파일)을 삭제하고 로그 로테이션을 설정합니다.\n2. 'iostat', 'iotop'으로 I/O 병목 지점을 확인하고, 과도한 I/O 유발 프로세스를 개선합니다.\n3. 파일 시스템 오류 여부를 확인하고, 필요시 복구 작업을 수행합니다.\n4. 디스크 용량 추가 또는 고성능 디스크(SSD)로의 교체를 고려합니다.";
                    break;
                case 'network_top_api_6h': case 'network':
                    reportTitle = "네트워크 트래픽 및 연결 상태 분석 보고서";
                    reportContent += "[상세 분석 및 권고]\n과도한 네트워크 트래픽 또는 잦은 연결 오류는 서비스 품질에 영향을 줍니다.\n\n";
                    reportContent += `[전체 기간 네트워크 트래픽(In+Out) TOP${topN} 서버 (평균)]\n${getResourceTopNString('network', ' Mbps')}`;
                    reportContent += "\n[조치 권고 사항]\n1. 'iftop', 'nethogs', 'tcpdump' 등으로 트래픽 발생량, 프로토콜, IP를 분석하여 비정상 트래픽을 식별합니다.\n2. 'netstat', 'ss' 명령으로 연결 상태를 확인하고, 과도한 연결 또는 연결 실패 원인을 파악합니다.\n3. DDoS 공격, 악성코드 감염, 외부 서비스 연동 문제 등을 확인합니다.\n4. 네트워크 인터페이스 설정, 방화벽 규칙을 검토하고, 필요시 대역폭 증설 또는 로드밸런서 도입을 고려합니다.";
                    break;
                case 'application_orderservice_error': case 'application_error':
                    reportTitle = "애플리케이션 오류 분석 보고서";
                    reportContent += "[상세 분석 및 권고]\n애플리케이션 레벨에서 오류가 발생한 서버에 대한 분석입니다.\n";
                    if (affectedServersFromNlp.length > 0) {
                        reportContent += "\n[질의 관련 오류 발생 서버 목록]\n";
                        affectedServersFromNlp.forEach(s => {
                            const appAlerts = (allServerData.find(d => d.serverHostname === s.name)?.alerts || [])
                                .filter(al => al.type === 'Application' && (query.includes('OrderService') ? al.message.includes('OrderService') : true))
                                .map(al => `[${al.severity}] ${al.message}`).join('; ');
                            if(appAlerts) reportContent += `- ${s.name} (타입: ${s.type}, 위치: ${s.location})\n   오류 내용: ${appAlerts}\n`;
                        });
                    } else { reportContent += "\n현재 조건에서 애플리케이션 오류가 발생한 서버를 찾지 못했습니다.\n"; }
                    reportContent += "\n[조치 권고 사항]\n1. 해당 서버의 애플리케이션 로그 상세 분석 및 스택 트레이스 확인.\n2. 오류 발생 코드 특정 및 재현 테스트, 버그 수정 및 패치 배포.\n3. APM 도구를 활용한 실시간 오류 모니터링 강화.";
                    break;
                 case 'security_login_fail_24h': case 'security':
                    reportTitle = "보안 경고 분석 보고서";
                    reportContent += "[상세 분석 및 권고]\n보안 관련 경고가 발생한 서버에 대한 분석입니다.\n";
                     if (affectedServersFromNlp.length > 0) {
                        reportContent += "\n[질의 관련 보안 경고 발생 서버 목록]\n";
                        affectedServersFromNlp.forEach(s => {
                            const secAlerts = (allServerData.find(d => d.serverHostname === s.name)?.alerts || [])
                                .filter(al => al.type === 'Security' && (query.includes('로그인 실패') ? (al.message.includes('로그인') || al.message.toLowerCase().includes('login')) : true ) )
                                .map(al => `[${al.severity}] ${al.message}`).join('; ');
                            if(secAlerts) reportContent += `- ${s.name} (타입: ${s.type}, 위치: ${s.location})\n   경고 내용: ${secAlerts}\n`;
                        });
                    } else { reportContent += "\n현재 조건에서 보안 경고가 발생한 서버를 찾지 못했습니다.\n"; }
                    reportContent += "\n[조치 권고 사항]\n1. 침해 사고 분석 및 영향 범위 확인, 관련 계정 암호 변경 및 접근 통제 강화.\n2. 최신 보안 패치 적용 및 시스템 보안 설정 강화, 방화벽 및 IDS/IPS 정책 검토.\n3. 정기적인 보안 취약점 점검 수행.";
                    break;
                case 'batch_job_yesterday':
                     reportTitle = "어제 실행된 BATCH 서버 작업 상태 요약 보고서";
                     reportContent += "[상세 분석 및 권고]\n어제 실행된 BATCH 서버들의 작업 관련 경고 및 상태 분석입니다.\n";
                     const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1);
                     const batchServersYesterday = (allServerData || [])
                        .filter(d => {
                            const itemDate = new Date(d.timestamp);
                            return d.serverType === 'BATCH' && 
                                   itemDate.getFullYear() === yesterday.getFullYear() &&
                                   itemDate.getMonth() === yesterday.getMonth() &&
                                   itemDate.getDate() === yesterday.getDate() &&
                                   d.alerts.some(al => al.type === 'Process' || al.message.toLowerCase().includes('batch'));
                        })
                        .sort((a,b) => b.alerts.length - a.alerts.length || new Date(b.timestamp) - new Date(a.timestamp))
                        .slice(0,5);
                    if (batchServersYesterday.length > 0) {
                        reportContent += "\n[어제 주요 BATCH 서버 상태]\n";
                        batchServersYesterday.forEach(s_evt => {
                             const batchAlerts = s_evt.alerts.filter(al => al.type === 'Process' || al.message.toLowerCase().includes('batch')).map(al => `[${al.severity}] ${al.message}`).join('; ');
                             reportContent += `- ${s_evt.serverHostname.split('.')[0]} (${s_evt.location}) - ${new Date(s_evt.timestamp).toLocaleTimeString('ko-KR')}\n`;
                             reportContent += `  상태: ${s_evt.status}, 경고: ${batchAlerts || "특이사항 없음"}\n`;
                        });
                    } else { reportContent += "\n어제 실행된 BATCH 서버 중 특이사항을 찾지 못했습니다.\n"; }
                    reportContent += "\n[조치 권고 사항]\n1. BATCH 작업 스케줄러 및 실행 로그 확인.\n2. 실패한 작업이 있다면 원인 분석 및 재실행.\n3. 작업 수행 시간, 리소스 사용량 등을 모니터링하여 최적화.";
                    break;
                case 'critical_location_cause':
                case 'critical_error_today':
                case 'error_status': 
                case 'generic_problem_summary':
                default: 
                    reportTitle = `${(detectedReportType || 'GENERIC_PROBLEM').replace(/_/g, ' ').toUpperCase()} 종합 분석 보고서`;
                    reportContent += `[상세 분석 및 권고]\n선택된 질의 조건에 따라 다음 서버들에서 주요 문제/상태가 식별되었습니다.\n\n`;
                    if (affectedServersFromNlp.length > 0) {
                        affectedServersFromNlp.forEach(s => {
                            reportContent += `- 서버: ${s.name} (유형: ${s.type}, 위치: ${s.location})\n`;
                            reportContent += `  분석 점수: ${s.score}, Critical:${s.criticalAlertCount}, Error:${s.errorAlertCount}, Warning:${s.warningAlertCount}\n`;
                            reportContent += `  주요 문제/경고: ${s.recentProblemMessages}\n`;
                            const serverEvents = (allServerData || [])
                                .filter(d => d.serverHostname === s.name && d.alerts.length > 0)
                                .sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp))
                                .slice(0, 2); 
                            if (serverEvents.length > 0) {
                                reportContent += `  최근 상세 경고 이벤트:\n`;
                                serverEvents.forEach(evt => {
                                    evt.alerts.forEach(al => {
                                        reportContent += `    - ${new Date(al.timestamp || evt.timestamp).toLocaleString('ko-KR')}: [${al.severity}/${al.type}] ${al.message}\n`;
                                    });
                                });
                            }
                            reportContent += "\n";
                        });
                    } else { reportContent += "해당 조건에 특이사항이 있는 서버를 찾지 못했습니다.\n\n"; }
                    reportContent += `[일반 조치 권고]\n1. 식별된 서버의 시스템 및 애플리케이션 로그를 즉시 확인하여 문제의 근본 원인을 파악합니다.\n2. 문제의 심각도와 서비스 영향도에 따라 긴급 복구 또는 계획된 유지보수를 진행합니다.\n3. 동일 문제 재발 방지를 위해 원인 분석 결과를 바탕으로 시스템 설정 변경, 코드 수정, 모니터링 강화 등의 후속 조치를 수행합니다.`;
                    break;
            }
            return { title: reportTitle, content: reportContent };
        }
        
        function interpretAndExecuteNLPQuery(query) { /* 이전 답변의 강화된 해석 로직 그대로 사용 */
            showLoading();
            const explanationEl = document.getElementById('nlp-explanation');
            const resultListEl = document.getElementById('nlp-summary-list');
            const reportButtonContainer = document.getElementById('nlp-report-button-container');

            if (!explanationEl || !resultListEl || !reportButtonContainer) {
                console.error("NLP UI elements not found."); hideLoading(); return;
            }

            resultListEl.innerHTML = ''; reportButtonContainer.innerHTML = ''; 

            let timeRange = 24; let serverType = 'all'; let alertFilter = 'all'; let location = 'all';
            let interpretationParts = []; 
            let detectedReportType = 'generic_problem_summary'; 

            const lowerQuery = query.toLowerCase();
            const originalQueryForReport = query; 

            const selectedOption = document.querySelector(`#nlp-query-select option[value="${query}"]`);
            if (selectedOption && selectedOption.dataset.reportType) {
                detectedReportType = selectedOption.dataset.reportType;
            }

            const timePatterns = [
                { pattern: /최근\s*(\d+)\s*시간/i, value: (match) => parseInt(match[1]), label: (m) => `최근 ${m[1]}시간`},
                { pattern: /최근\s*(\d+)\s*일/i, value: (match) => parseInt(match[1]) * 24, label: (m) => `최근 ${m[1]}일`},
                { pattern: /어제/i, value: () => { // 어제 00:00 ~ 23:59 (좀 더 정확하게)
                        const today = new Date();
                        const yesterdayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1, 0, 0, 0);
                        const yesterdayEnd = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1, 23, 59, 59);
                        // applyFilters에서 이 특정 시간 범위를 처리할 수 있도록 수정 필요 또는 timeRangeHours로만 전달
                        return 24; // 단순화: 일단 지난 24시간 (dataProcessor.applyFilters 수정 필요)
                    }, label: () => "어제"},
                { pattern: /오늘/i, value: () => new Date().getHours(), label: () => "오늘 (00시부터 현재까지)"}
            ];
            for (const tp of timePatterns) {
                const match = lowerQuery.match(tp.pattern);
                if (match) {
                    if (lowerQuery.includes("어제")) { // '어제' 키워드 특별 처리
                         const today = new Date();
                         const yesterdayStartMs = new Date(today.getFullYear(), today.getMonth(), today.getDate() -1, 0,0,0).getTime();
                         const nowMs = today.getTime();
                         timeRange = Math.max(1, Math.floor((nowMs - yesterdayStartMs) / (1000 * 60 * 60)) ); // 어제 00시부터 지금까지의 시간
                         // 하지만 실제 데이터는 7일치이므로, '어제'는 24~48시간 전 데이터로 해석될 수 있음.
                         // data_processor.js의 applyFilters에서 timeRangeHours 대신 startDate, endDate를 직접 받는 로직 추가 필요
                         // 여기서는 일단 24시간 전부터 ~ 48시간 전까지의 데이터는 필터링 안되므로, "어제 BATCH 작업 상태"는 dummy data 생성시 어제 날짜로 이벤트를 만들어야함.
                         // 또는 timeRange를 {start: Date, end: Date} 객체로 넘기는 방식 고려.
                         // 현재는 가장 최근 24시간 기준으로 동작. "어제" 필터링은 data_processor에서 개선 필요.
                         timeRange = 48; // 임시: 최근 48시간 내에서 어제 데이터가 포함되도록
                         interpretationParts.push(`시간: 어제 (대략 최근 24-48시간)`);
                    } else if (lowerQuery.includes("오늘")) {
                        timeRange = new Date().getHours() +1; // 오늘 0시부터 현재시간까지
                        interpretationParts.push(`시간: 오늘 (00시~현재)`);
                    }
                    else {
                        timeRange = tp.value(match);
                        interpretationParts.push(`시간: ${tp.label(match)}`);
                    }
                    break;
                }
            }
            
            const uniqueServerTypes = dataProcessor ? dataProcessor.getUniqueServerTypes() : [];
            for (const type of uniqueServerTypes) {
                if (lowerQuery.includes(type.toLowerCase())) {
                    serverType = type;
                    interpretationParts.push(`서버 유형: ${type}`);
                    // detectedReportType 우선순위: 예시 질문 > 키워드 > 일반
                    if (detectedReportType === 'generic_problem_summary' && type === 'DB') detectedReportType = 'disk_critical_db'; // 예시
                    if (detectedReportType === 'generic_problem_summary' && type === 'WAS') detectedReportType = 'memory_leak_was'; // 예시
                    if (detectedReportType === 'generic_problem_summary' && type === 'API') detectedReportType = 'network_top_api_6h'; // 예시
                    if (detectedReportType === 'generic_problem_summary' && type === 'BATCH') detectedReportType = 'batch_job_yesterday'; // 예시
                    break; 
                }
            }
            
            const uniqueLocations = dataProcessor ? dataProcessor.getUniqueLocations() : [];
             for (const loc of uniqueLocations) {
                if (query.includes(loc)) { 
                    location = loc;
                    interpretationParts.push(`위치: ${loc}`);
                    break;
                }
            }
            
            const alertKeywordsMap = { /* 이전과 동일 */
                'cpu': {filter: 'CPU', report: 'cpu_high'},
                '메모리': {filter: 'Memory', report: 'memory_leak_was'}, 'memory': {filter: 'Memory', report: 'memory_leak_was'},
                '디스크': {filter: 'Disk', report: 'disk_critical_db'}, 'disk': {filter: 'Disk', report: 'disk_critical_db'}, '공간 부족': {filter: 'Disk', report: 'disk_space_critical'},
                '네트워크': {filter: 'Network', report: 'network_traffic_high'}, 'network': {filter: 'Network', report: 'network_traffic_high'}, '트래픽': {filter: 'Network', report: 'network_traffic_high'},
                'critical': {filter: 'Critical', report: 'critical_location_cause'}, '심각': {filter: 'Critical', report: 'critical_location_cause'},
                'error': {filter: 'Error', report: 'error_status'}, '오류': {filter: 'Error', report: 'error_status'},
                'warning': {filter: 'Warning', report: 'generic_problem_summary'}, '주의': {filter: 'Warning', report: 'generic_problem_summary'},
                '애플리케이션': {filter: 'Application', report: 'application_orderservice_error'}, 'application': {filter: 'Application', report: 'application_orderservice_error'},
                '보안': {filter: 'Security', report: 'security_login_fail_24h'}, 'security': {filter: 'Security', report: 'security_login_fail_24h'}, '로그인 실패': {filter: 'Security', report: 'security_login_fail_24h'},
            };

            let matchedKeywordForFilter = false;
            for (const keyword in alertKeywordsMap) {
                if (lowerQuery.includes(keyword)) {
                    alertFilter = alertKeywordsMap[keyword].filter;
                    // 예시 질문에서 명시적으로 reportType이 설정된 경우가 아니라면, 키워드로 reportType 추론
                    if (!selectedOption || !selectedOption.dataset.reportType) {
                         detectedReportType = alertKeywordsMap[keyword].report;
                    } else if (selectedOption.dataset.reportType === 'generic_problem_summary' || !selectedOption.dataset.reportType) {
                        // 예시 질문이 일반 요약이거나 reportType이 없다면 키워드 기반으로 설정
                        detectedReportType = alertKeywordsMap[keyword].report;
                    }
                    interpretationParts.push(`경고/상태 키워드: ${alertFilter}`);
                    matchedKeywordForFilter = true;
                    break; 
                }
            }
             // 만약 select에서 reportType이 명확히 지정되었고, 키워드에서 못찾았으면 select의 reportType 사용
            if (!matchedKeywordForFilter && selectedOption && selectedOption.dataset.reportType && selectedOption.dataset.reportType !== 'generic_problem_summary') {
                detectedReportType = selectedOption.dataset.reportType;
                // 이 reportType으로 alertFilter를 유추하는 로직 추가 가능
                if(detectedReportType.includes('cpu')) alertFilter = 'CPU';
                else if(detectedReportType.includes('memory')) alertFilter = 'Memory';
                // ... 등등
                interpretationParts.push(`주요 분석 대상 (선택): ${detectedReportType.replace(/_/g, ' ').toUpperCase()}`);
            }


            explanationEl.innerHTML = `<strong>해석된 조건:</strong> ${interpretationParts.length > 0 ? interpretationParts.join('; ') : "일반 전체 요약"}`;

            setTimeout(() => {
                try {
                    if (!dataProcessor) { throw new Error("DataProcessor가 초기화되지 않았습니다."); }
                    const filteredNlpDataForSummary = dataProcessor.applyFilters(timeRange, serverType, alertFilter, location);
                    const nlpSummary = dataProcessor.getProblematicServersSummary(filteredNlpDataForSummary, 5); 

                    renderNLPSummaryList(nlpSummary, originalQueryForReport, detectedReportType); 
                    
                    const llmGuidance = `현재 데모는 입력된 질의를 바탕으로 사전 정의된 규칙에 따라 필터링합니다. 실제 LLM(대규모 언어 모델)을 연동하면, "어제 오후부터 오늘 새벽 사이에 Seoul-IDC의 DB서버 중 디스크 사용률이 80%를 넘고 CPU 부하도 높았던 서버들의 로그 요약해줘" 와 같이 복잡하고 미묘한 자연어 질문도 이해하여, 다중 조건(시간 범위, 위치, 서버타입, 지표 임계치, 경고 패턴 등)으로 변환하고, 그 결과를 바탕으로 심층 분석 및 요약 보고서를 동적으로 생성할 수 있습니다. 또한, 과거 이력 및 유사 장애 패턴을 학습하여 잠재적인 문제 예측 및 선제적 대응 방안 제시도 가능해집니다.`;
                    explanationEl.innerHTML += `<br><br><details><summary><strong>LLM 활용 상세 방안 (클릭)</strong></summary><p style="font-size:0.9em; padding-left:15px;">${llmGuidance}</p></details>`;

                } catch (e) {
                    console.error("NLP 질의 처리 중 오류:", e);
                    if(resultListEl) resultListEl.innerHTML = `<p style="color:red;">질의 처리 중 오류가 발생했습니다: ${e.message}</p>`;
                } finally {
                    hideLoading();
                }
            }, 500); 
        }
        
        function applyAndRenderLegacyFilters() { /* 이전과 동일 */
            showLoading();
            setTimeout(() => {
                try {
                    if (!dataProcessor) { hideLoading(); return; }
                    const timeRange = document.getElementById('time-filter').value;
                    const serverType = document.getElementById('server-type-filter').value;
                    const alertForProblemAnalysis = document.getElementById('alert-filter').value;
                    const location = document.getElementById('location-filter').value;

                    const baseFilteredData = dataProcessor.applyFilters(parseInt(timeRange), serverType, 'all', location);
                    renderTopResourceList('cpu-top-list', dataProcessor.getTopNServersByResource(baseFilteredData, 'cpu'));
                    renderTopResourceList('memory-top-list', dataProcessor.getTopNServersByResource(baseFilteredData, 'memory'));
                    renderTopResourceList('disk-top-list', dataProcessor.getTopNServersByResource(baseFilteredData, 'disk'));
                    renderTopResourceList('network-top-list', dataProcessor.getTopNServersByResource(baseFilteredData, 'network'));
                    
                    const problemFilteredData = dataProcessor.applyFilters(parseInt(timeRange), serverType, alertForProblemAnalysis, location);
                    renderProblematicServersList(dataProcessor.getProblematicServersSummary(problemFilteredData));

                    updateTimestamp();
                } catch (error) {
                    console.error('기존 필터 적용 및 렌더링 오류:', error);
                } finally {
                    hideLoading();
                }
            }, 50);
        }
        
        function updateTimestamp() { /* 이전과 동일 */
            const timestampEl = document.getElementById('timestamp');
            if (timestampEl) {
                const dataEndTime = allServerData && allServerData.length > 0 ? new Date(Math.max(...allServerData.map(d => new Date(d.timestamp).getTime()))) : new Date();
                timestampEl.textContent = `데이터 기준 시각: ${dataEndTime.toLocaleString('ko-KR', { year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false })}`;
            }
        }

        function setupEventListeners() { /* 이전과 동일 */
             const nlpInput = document.getElementById('nlp-query-input');
             const nlpSelect = document.getElementById('nlp-query-select');
             const nlpSubmitBtn = document.getElementById('nlp-submit-btn');

             if(nlpSelect) {
                nlpSelect.addEventListener('change', function() {
                    if (this.value && nlpInput) { 
                        nlpInput.value = this.value;
                    }
                });
             }
             if(nlpSubmitBtn && nlpInput) { 
                nlpSubmitBtn.addEventListener('click', function() {
                    const query = nlpInput.value.trim();
                    if (query) interpretAndExecuteNLPQuery(query);
                    else alert("질의를 입력하거나 예시를 선택해주세요.");
                });
             }
             if(nlpInput) {
                 nlpInput.addEventListener('keypress', function(e) {
                     if (e.key === 'Enter') {
                         const query = nlpInput.value.trim();
                         if (query) interpretAndExecuteNLPQuery(query);
                         e.preventDefault(); 
                     }
                 });
             }

             const legacyApplyBtn = document.getElementById('apply-filter-btn');
             if(legacyApplyBtn) legacyApplyBtn.addEventListener('click', applyAndRenderLegacyFilters);
             
             const csvBtn = document.getElementById('download-csv-btn');
             if(csvBtn) csvBtn.addEventListener('click', downloadCombinedCSV);

             if(modalCloseBtn) {
                modalCloseBtn.onclick = function() {
                    if(reportModal) reportModal.style.display = "none";
                }
             }
             window.onclick = function(event) { 
                if (event.target == reportModal) {
                    if(reportModal) reportModal.style.display = "none";
                }
             }
        }

        function downloadCombinedCSV() { /* 이전과 동일 */
            showLoading();
            try {
                if (!dataProcessor) { alert("데이터 미로드"); hideLoading(); return; }
                const timeRange = document.getElementById('time-filter').value;
                const serverType = document.getElementById('server-type-filter').value;
                const locationVal = document.getElementById('location-filter').value;
                const alertForProblemAnalysis = document.getElementById('alert-filter').value;

                const baseFilteredData = dataProcessor.applyFilters(parseInt(timeRange), serverType, 'all', locationVal);
                const problemFilteredData = dataProcessor.applyFilters(parseInt(timeRange), serverType, alertForProblemAnalysis, locationVal);

                let csvContent = "항목,서버명,서버타입,위치,값/점수,단위/상세정보\n";
                
                const resources = [
                    {key: 'cpu', name: 'CPU 사용률 TOP5'}, {key: 'memory', name: '메모리 사용률 TOP5'},
                    {key: 'disk', name: '디스크 사용률 TOP5'}, {key: 'network', name: '네트워크 트래픽 TOP5'}
                ];
                resources.forEach(res => {
                    const topServers = dataProcessor.getTopNServersByResource(baseFilteredData, res.key);
                    (topServers || []).forEach(s => {
                        csvContent += `"${res.name}","${s.name || ''}","${s.type || ''}","${s.location || ''}",${s.avgUsage !== undefined ? s.avgUsage.toFixed(1) : ''},"${s.unit || ''}"\n`;
                    });
                });

                const problemServers = dataProcessor.getProblematicServersSummary(problemFilteredData);
                (problemServers || []).forEach(s => {
                    const details = `C:${s.criticalAlertCount || 0}/E:${s.errorAlertCount || 0}/W:${s.warningAlertCount || 0} | ${(s.recentProblemMessages || '').replace(/"/g, '""')}`;
                    csvContent += `"문제서버 TOP5","${s.name || ''}","${s.type || ''}","${s.location || ''}",${s.score || 0},"${details}"\n`;
                });

                const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.setAttribute("href", url);
                link.setAttribute("download", `OpenManager_분석요약_${new Date().toISOString().slice(0,10)}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            } catch (error) {
                console.error('CSV 다운로드 오류:', error);
                alert('CSV 파일 생성 중 오류가 발생했습니다.');
            } finally {
                hideLoading();
            }
        }

        // --- 페이지 초기화 ---
        document.addEventListener('DOMContentLoaded', function() {
            showLoading();
            try {
                if (typeof getFixedDummyData !== 'function' ) {
                    console.error("getFixedDummyData is not defined!"); alert("데이터 생성 스크립트 오류."); hideLoading(); return;
                }
                allServerData = getFixedDummyData();
                console.log(`고정 더미 데이터 ${allServerData.length}개 로드 완료.`);

                if (!allServerData || allServerData.length === 0) {
                     alert("로드된 서버 데이터가 없습니다."); hideLoading(); return;
                }
                
                if (typeof ServerDataProcessor !== 'function') {
                    console.error("ServerDataProcessor is not defined!"); alert("데이터 처리 스크립트 오류."); hideLoading(); return;
                }
                dataProcessor = new ServerDataProcessor(allServerData);
                console.log('DataProcessor 초기화 완료.');
                
                initializeLegacyFilters(); 
                applyAndRenderLegacyFilters(); 
                setupEventListeners();

            } catch (error) {
                console.error('페이지 초기화 중 오류:', error);
                alert('페이지 초기화 중 오류 발생. 콘솔 확인.');
            } finally {
                hideLoading(); 
            }
        });
    </script>
</body>
</html>
