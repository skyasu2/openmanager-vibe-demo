<script src="fixed_dummy_data.js"></script> <script src="data_processor.js"></script>

<script>
    // 전역 변수
    let allServerData = []; // 모든 고정 데이터를 담을 변수
    let dataProcessor = null;
    
    // 페이지 로드 시 데이터 로딩
    document.addEventListener('DOMContentLoaded', async function() {
        try {
            // 고정 더미 데이터 로드
            allServerData = getFixedDummyData(); // fixed_dummy_data.js의 함수 호출
            console.log(`고정 더미 데이터 ${allServerData.length}개 로드 완료.`);
            
            // 데이터 처리기 초기화
            dataProcessor = new ServerDataProcessor(allServerData);
            
            // 필터 적용 (초기 로드)
            applyFilters();
            
            // 이벤트 리스너 설정
            setupEventListeners();
            
            document.getElementById('loading-overlay').style.display = 'none';
            
        } catch (error) {
            console.error('데이터 로딩 중 오류 발생:', error);
            alert('서버 데이터를 로드하는데 실패했습니다.');
            document.getElementById('loading-overlay').style.display = 'none';
        }
    });
    
    // async function loadServerData() { ... } 이 함수는 이제 필요 없거나,
    // getFixedDummyData()를 호출하는 간단한 형태로 변경할 수 있습니다.
    // 여기서는 직접 DOMContentLoaded에서 처리했습니다.

    // generateDummyData() 함수는 삭제합니다.

    function applyFilters() {
        document.getElementById('loading-overlay').style.display = 'flex';
        
        setTimeout(() => {
            try {
                const timeRange = document.getElementById('time-filter').value; // "24" 등 문자열
                const serverType = document.getElementById('server-filter').value;
                const alertType = document.getElementById('alert-filter').value; // "CPU 사용률" 등 문자열
                
                // dataProcessor.applyFilters는 이제 전체 데이터(allServerData)를 내부적으로 사용하므로
                // 별도로 데이터를 넘길 필요가 없을 수도 있지만,
                // 만약 applyFilters가 항상 새로운 데이터셋에 대해 동작하도록 설계했다면,
                // dataProcessor = new ServerDataProcessor(allServerData); // 필터 적용 전 항상 최신 데이터로 초기화
                // const filteredData = dataProcessor.applyFilters(parseInt(timeRange), serverType, alertType);

                // 또는 ServerDataProcessor가 내부 데이터를 가지고 필터링한다면:
                const filteredData = dataProcessor.applyFilters(parseInt(timeRange), serverType, alertType);
                                
                const topServers = dataProcessor.countAlertsByServer(filteredData);
                updateServerTable(topServers.slice(0, 5));
                updateTimestamp();
                document.getElementById('loading-overlay').style.display = 'none';
            } catch (error) {
                console.error('필터 적용 중 오류 발생:', error);
                alert('데이터 필터링 중 오류가 발생했습니다.');
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }, 100); // UI 반응성을 위해 약간의 지연
    }

    function updateServerTable(servers) {
        const tableBody = document.getElementById('server-list');
        tableBody.innerHTML = '';
        
        if (servers.length === 0) {
            // ... (기존 코드)
            return;
        }
        
        servers.forEach(server => {
            const row = document.createElement('tr');
            
            const nameCell = document.createElement('td');
            // server.name 은 이제 serverHostname 입니다.
            // server.count 는 동일, server.mainIssue도 countAlertsByServer에서 생성
            if (server.count >= 5) { // 이 조건은 유지하거나 경고 심각도에 따라 변경 가능
                const alertIcon = document.createElement('span');
                alertIcon.className = 'alert-icon';
                alertIcon.textContent = '⚠'; // 아이콘은 유지
                nameCell.appendChild(alertIcon);
            }
            nameCell.appendChild(document.createTextNode(server.name)); // server.name은 serverHostname
            row.appendChild(nameCell);
            
            // ... (countCell, issueCell 기존 로직과 유사하게 server 객체의 필드명 확인)
            const countCell = document.createElement('td');
            countCell.textContent = `${server.count}건`;
            if (server.count >= 10 && server.mainIssue.toLowerCase().includes('critical')) { // 예시: Critical 경고가 많을 때
                countCell.className = 'error-count';
            } else if (server.count >= 5) {
                countCell.className = 'warning-count';
            }
            row.appendChild(countCell);

            const issueCell = document.createElement('td');
            issueCell.textContent = server.mainIssue; // countAlertsByServer 에서 생성된 값
            row.appendChild(issueCell);

            tableBody.appendChild(row);
        });
    }

    // runAnalysis, downloadCSV, updateTimestamp, setupEventListeners 함수는
    // dataProcessor나 필터링된 데이터를 사용하는 부분에서 필드명 변경에 유의해야 합니다.
    // 예를 들어 CSV 다운로드 시 server.name, server.mainIssue 등을 사용합니다.

    // CSV 다운로드 함수 (데이터 구조 변경 반영)
    function downloadCSV() {
        try {
            const timeRange = parseInt(document.getElementById('time-filter').value);
            const serverType = document.getElementById('server-filter').value;
            const alertType = document.getElementById('alert-filter').value;
            
            const filteredData = dataProcessor.applyFilters(timeRange, serverType, alertType);
            const serversForCsv = dataProcessor.countAlertsByServer(filteredData); // 요약된 서버 목록
            
            let csvContent = "서버 호스트네임,서버 유형,경고 건수,주요 경고 내용\n";
            
            serversForCsv.forEach(server => {
                // server.type은 countAlertsByServer에서 추가됨
                csvContent += `${server.name},${server.type || 'N/A'},${server.count},"${(server.mainIssue || '').replace(/"/g, '""')}"\n`;
            });
            
            // ... (Blob 생성 및 다운로드 로직은 기존과 동일)
            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' }); // BOM 추가 (Excel 한글 깨짐 방지)
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            
            link.setAttribute("href", url);
            link.setAttribute("download", `서버_상태_요약_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

        } catch (error) {
            console.error('CSV 다운로드 중 오류 발생:', error);
            alert('CSV 파일 생성 중 오류가 발생했습니다.');
        }
    }
    // ... (나머지 함수들) ...
</script>
</body>
</html>
